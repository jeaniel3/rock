---

- name: Kube | Get kube-dns IP
  shell: "kubectl get svc -n kube-system | grep kube-dns | awk '{print $3}'"
  register: kube_dns_ip

- name: Verify kube_dns is valid
  fail:
    msg: "We were not able to get kubedns with kubectl get svc -n kube-system | grep kube-dns | awk '{print $3}'. Kubedns value is {{ kube_dns_ip }}. This means we couldn't update resolv.conf with kubedns which would cause a failure so we are exiting. This means that for whatever reason Kubernetes' DNS service wasn't running."
  when: (kube_dns_ip.stdout | ipv4) != kube_dns_ip.stdout

# This task retrieves the connection name of the network device with the management IP designated
# in the inventory file
- name: Kube | Get network manager connection name
  shell: nmcli device show {{ item }} | grep GENERAL.CONNECTION | awk -F "GENERAL.CONNECTION{{":"}} *" '{print $2}'
  register: nmcli_conn_name
  with_items: "{{ ansible_interfaces }}"
  when:
    - hostvars[inventory_hostname]['ansible_' + item] is defined
    - hostvars[inventory_hostname]['ansible_' + item].ipv4 is defined
    - hostvars[inventory_hostname]['ansible_' + item].ipv4.address == hostvars[inventory_hostname].management_ipv4

- name: Kube | Update DNS records for the management interface
  nmcli:
    conn_name: "{{ item.stdout }}"
    type: ethernet
    autoconnect: yes
    dns4:
      - "{{ kube_dns_ip.stdout }}"
      - "{{ dns_ip }}"
    state: present
  with_items: "{{ nmcli_conn_name.results }}"
  when: item.stdout is defined

- name: Kube | Insert kube-dns into /etc/resolv.conf
  lineinfile:
    insertbefore: BOF
    line: "nameserver {{ kube_dns_ip.stdout }}"
    path: /etc/resolv.conf

...
